package edu.albany.cs.utils;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Random;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math3.random.RandomDataGenerator;

import edu.albany.cs.apdmIO.APDMInputFormat;
import edu.albany.cs.base.ConnectedComponents;
import edu.albany.cs.base.Edge;

public class GenerateGridData {


	public void generateGridDataWithNoise(int numTrueNodes,String gridDataFileName,double alpha,double noiseLevel,String outPutFileName ) throws IOException{

		APDMInputFormat apdm = new APDMInputFormat(gridDataFileName) ;
		//usedAlgorithm, dataSource, edges,tredges, PValue, fileName
		String usedAlgorithm = "KCCSM" ;
		String dataSource = "GridDataset" ;
		ArrayList<Edge> treEdges = this.randomWalk(apdm.data.graphAdjList, numTrueNodes) ;
		double[] PValue = new double[apdm.data.numNodes] ;
		int[] trueNodes = null ;
		Arrays.fill(PValue, 1.0) ;
		for(Edge e:treEdges){
			PValue[e.i] = alpha ;
			PValue[e.j] = alpha ;
			if(!ArrayUtils.contains(trueNodes, e.i)){
				trueNodes = ArrayUtils.add(trueNodes, e.i) ;	
			}
			if(!ArrayUtils.contains(trueNodes, e.j)){
				trueNodes = ArrayUtils.add(trueNodes, e.j) ;	
			}
		}

		int noiseLevelInTrueNodes =(int)(((noiseLevel + 0.0)/100)*(trueNodes.length)) ;
		int[] alreadyDone = null ;
		for( int k = 0 ; k < noiseLevelInTrueNodes ; k++){
			while(true){
				int valueToFind = new Random().nextInt(trueNodes.length);
				if(!ArrayUtils.contains(alreadyDone, valueToFind)){
					PValue[trueNodes[valueToFind]] = 1.0 ;
					alreadyDone = ArrayUtils.add(alreadyDone, valueToFind) ;
					break ;
				}
			}
		}

		int[] normalNodes = ArrayUtils.removeElements(new RandomDataGenerator().nextPermutation(PValue.length, PValue.length), trueNodes) ;
		int noiseLevelInNormalNodes =(int)(((noiseLevel+0.0)/100)*(PValue.length - trueNodes.length + 0.0)) ;
		alreadyDone = null ;
		for( int j = 0 ; j < noiseLevelInNormalNodes ; j++){
			while(true){
				int valueToFind = new Random().nextInt(normalNodes.length) ;
				if(!ArrayUtils.contains(alreadyDone, valueToFind)){
					PValue[normalNodes[valueToFind]] = alpha ;
					alreadyDone = ArrayUtils.add(alreadyDone, valueToFind) ;
					break ;
				}
			}
		}
		
		APDMInputFormat.generateAPDMFile(usedAlgorithm, dataSource, apdm.data.newEdges, PValue,null,null,treEdges, outPutFileName);
	}

	public void generateGridDataWithNoise(int numTrueNodes,int NumOfNodes,double alpha,double noiseLevel,String outPutFileName, boolean flag ) throws IOException{

		//usedAlgorithm, dataSource, edges,tredges, PValue, fileName
		String usedAlgorithm = "NULL" ;
		String dataSource = "GridDataset" ;
		GenerateSingleGrid g = new GenerateSingleGrid(NumOfNodes) ;
		ArrayList<Edge> treEdges = this.randomWalk(g.adj, numTrueNodes) ;
		double[] PValue = new double[g.numOfNodes] ;
		int[] trueNodes = null ;
		Arrays.fill(PValue, 1.0) ;
		for(Edge e:treEdges){
			PValue[e.i] = alpha ;
			PValue[e.j] = alpha ;
			if(!ArrayUtils.contains(trueNodes, e.i)){
				trueNodes = ArrayUtils.add(trueNodes, e.i) ;	
			}
			if(!ArrayUtils.contains(trueNodes, e.j)){
				trueNodes = ArrayUtils.add(trueNodes, e.j) ;	
			}
		}

		int noiseLevelInTrueNodes =(int)(((noiseLevel + 0.0)/100)*(trueNodes.length)) ;
		int[] alreadyDone = null ;
		for( int k = 0 ; k < noiseLevelInTrueNodes ; k++){
			while(true){
				int valueToFind = new Random().nextInt(trueNodes.length);
				if(!ArrayUtils.contains(alreadyDone, valueToFind)){
					PValue[trueNodes[valueToFind]] = 1.0 ;
					alreadyDone = ArrayUtils.add(alreadyDone, valueToFind) ;
					break ;
				}
			}
		}

		int[] normalNodes = ArrayUtils.removeElements(new RandomDataGenerator().nextPermutation(PValue.length, PValue.length), trueNodes) ;
		int noiseLevelInNormalNodes =(int)(((noiseLevel+0.0)/100)*(PValue.length - trueNodes.length + 0.0)) ;
		alreadyDone = null ;
		for( int j = 0 ; j < noiseLevelInNormalNodes ; j++){
			while(true){
				int valueToFind = new Random().nextInt(normalNodes.length) ;
				if(!ArrayUtils.contains(alreadyDone, valueToFind)){
					PValue[normalNodes[valueToFind]] = alpha ;
					alreadyDone = ArrayUtils.add(alreadyDone, valueToFind) ;
					break ;
				}
			}
		}
		APDMInputFormat.generateAPDMFile(usedAlgorithm, dataSource, g.edges, PValue,null,null,treEdges,outPutFileName);
	}

	/**
	 * get number of nodes using the random walk algorithm 
	 * @param arr the graph adjacency list
	 * @param numTrueNodes the number of true nodes in the random walk algorithm
	 * @return the edges generated by the random walk algorithm
	 */
	private ArrayList<Edge> randomWalk(ArrayList<ArrayList<Integer>> arr,int numTrueNodes){

		ArrayList<Edge> trueSubGraph = new ArrayList<Edge>();
		Random random  = new Random() ;
		int start = random.nextInt(arr.size()) ;
		int size = numTrueNodes ;
		HashSet<Integer> h = new HashSet<Integer>() ;
		h.add(start) ;
		int count = 0 ;
		while(h.size()< size){
			int next = arr.get(start).get(random.nextInt(arr.get(start).size())) ;
			h.add(next) ;
			trueSubGraph.add(new Edge(start,next,count++,1.00000)) ;
			start = next ;
		}
		ArrayList<Edge> reducedTreEdges = new ArrayList<Edge>() ;
		for(Edge edge:trueSubGraph){
			if(!checkExist(reducedTreEdges,edge)){
				reducedTreEdges.add(edge) ;
			}
		}
		return reducedTreEdges ;
	}

	/**
	 * check the edge exists in the trueSubGraph
	 * @param trueSubGraph
	 * @param edge
	 * @return true if this edge contains in trueSubGraph else will return false
	 */
	private boolean checkExist(ArrayList<Edge> trueSubGraph,Edge edge){
		if(trueSubGraph.isEmpty()){
			return false ;
		}
		for(Edge ed:trueSubGraph){
			if((ed.i == edge.i && ed.j == edge.j) || (ed.i == edge.j && ed.j == edge.i) ){
				return true ;
			}
		}
		return false ;
	}

	public void generateSingleCase() throws IOException{
			int graphSize =2500 ;
			int numOfTrueNodes = 125 ;
			double alpha = 0.14D ;
			double noiseLevel = 0.0D ;
			String outputFileName = "data/DifferentialPrivacy/APDM-GridData-"+graphSize+"_noise_"+noiseLevel+"_trueSubSize_"+numOfTrueNodes+".txt" ;
			generateGridDataWithNoise(numOfTrueNodes,graphSize,alpha,noiseLevel,outputFileName,false);
			testTrueSubGraph(outputFileName);
			
	}
	
	public void testTrueSubGraph(String fileName){
		APDMInputFormat apdm = new APDMInputFormat(fileName);
		System.out.println(apdm.data.trueSubGraphNodes.length);
		ConnectedComponents cc =  apdm.data.cc;
		System.out.println(cc.computeCCSubGraph(apdm.data.trueSubGraphNodes));
	}

	public static void main(String args[]) throws IOException{
		
		GenerateGridData g = new GenerateGridData() ;
		g.generateSingleCase();
		
	}
}
